<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Ice Bear都能懂的RabbitMQ (二)]]></title>
      <url>http://skydream.me/post/2016/rabbitmq-beginner-guider-for-ice-bears-logsystem/</url>
      <content type="html"><![CDATA[<h2 id="fanout-exchange"><a href="#fanout-exchange" class="headerlink" title="fanout exchange"></a>fanout exchange</h2><p><a href="http://skydream.me/post/2016/rabbitmq-beginner-guider-for-ice-bears-helloworld/">《Ice Bear都能懂的RabbitMQ (一) 》</a>中，task_queue所解决的问题是，一个message只能被一种consumer所接收。现在我们有了新的需求，我们需要一个日志系统，我们希望有两种consumer，一种consumer将日志输出到屏幕，另一种consumer写到disk。为了实现这个目的，我们希望message被投到两个queue中，交给不同的consumer进行处理。<a id="more"></a>如下所示：</p>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-logsystem/two-consumer.png" alt="two-consumer"></p>
<!-- more -->
<p>对于producer，不再指定哪一个queue来接收消息，而是哪一个exchange来接收消息。exchange不保存信息，如果没有queue绑定在这个exchange上的话，消息就丢失了。代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: emit_log.py</span></div><div class="line"><span class="comment"># !/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'localhost'</span>))</div><div class="line">channel = connection.channel()</div><div class="line">channel.exchange_declare(exchange=<span class="string">'logs'</span>,</div><div class="line">                         type=<span class="string">'fanout'</span>)</div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"info: Hello World!"</span></div><div class="line">channel.basic_publish(exchange=<span class="string">'logs'</span>,</div><div class="line">                      routing_key=<span class="string">''</span>,</div><div class="line">                      body=message)</div><div class="line">print(<span class="string">" [x] Sent %r"</span> % message)</div><div class="line">connection.close()</div></pre></td></tr></table></figure></p>
<p>对于consumer，自己创建临时queue（<code>exclusive=True</code>，当这个consumer终止，这个queue就销毁），将这个queue接到exchange上，然后通过这个queue接收exchange发出的消息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: receive_logs.py</span></div><div class="line"><span class="comment"># !/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] %r"</span> % body)</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'localhost'</span>))</div><div class="line">channel = connection.channel()</div><div class="line">channel.exchange_declare(exchange=<span class="string">'logs'</span>,</div><div class="line">                         type=<span class="string">'fanout'</span>)</div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line">channel.queue_bind(exchange=<span class="string">'logs'</span>,</div><div class="line">                   queue=queue_name)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=queue_name,</div><div class="line">                      no_ack=<span class="keyword">True</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure></p>
<p>如下图所示，每一个consumer都建了自己的临时queue，并与exchange进行了绑定：<br><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-logsystem/fanout-exchange-list-queues.png" alt="fanout-exchange-list-queues"></p>
<h2 id="direct-exchange"><a href="#direct-exchange" class="headerlink" title="direct exchange"></a>direct exchange</h2><p>上面的例子中，queue_bind()的时候我们没有指定routing_key（为了避免混淆，后续将其称为binding_key）。binding_key的功能与exchange的类型有关。对于fanout exchange而言，binding_key没有意义。对于direct exchange而言，如下图所示，只有消息的routing_type与queue的binding_key相同时才会发送到该queue：<br><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-logsystem/direct-exchange.png" alt="direct-exchange"></p>
<p>可以指定相同的binding_key，如下图所示：<br><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-logsystem/direct-exchange-multiple.png" alt="direct-exchange-multiple"></p>
<p>借此，我们可以将日志系统改造为以下模式，不同的consumer只接收特定类型的日志信息：<br><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-logsystem/python-four.png" alt="python-four"></p>
<p>完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: emit_log.py</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">        host=<span class="string">'localhost'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line">channel.exchange_declare(exchange=<span class="string">'direct_logs'</span>,</div><div class="line">                         type=<span class="string">'direct'</span>)</div><div class="line"></div><div class="line">severity = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'info'</span></div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">2</span>:]) <span class="keyword">or</span> <span class="string">'Hello World!'</span></div><div class="line">channel.basic_publish(exchange=<span class="string">'direct_logs'</span>,</div><div class="line">                      routing_key=severity,</div><div class="line">                      body=message)</div><div class="line">print(<span class="string">" [x] Sent %r:%r"</span> % (severity, message))</div><div class="line">connection.close()</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: receiver_logs.py</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] %r:%r"</span> % (method.routing_key, body))</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'localhost'</span>))</div><div class="line">channel = connection.channel()</div><div class="line">channel.exchange_declare(exchange=<span class="string">'direct_logs'</span>,</div><div class="line">                         type=<span class="string">'direct'</span>)</div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"></div><div class="line">severities = sys.argv[<span class="number">1</span>:]</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> severities:</div><div class="line">    sys.stderr.write(<span class="string">"Usage: %s [info] [warning] [error]\n"</span> % sys.argv[<span class="number">0</span>])</div><div class="line">    sys.exit(<span class="number">1</span>)</div><div class="line"><span class="keyword">for</span> severity <span class="keyword">in</span> severities:</div><div class="line">    channel.queue_bind(exchange=<span class="string">'direct_logs'</span>,</div><div class="line">                       queue=queue_name,</div><div class="line">                       routing_key=severity)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=queue_name,</div><div class="line">                      no_ack=<span class="keyword">True</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h2 id="topic-exchange"><a href="#topic-exchange" class="headerlink" title="topic exchange"></a>topic exchange</h2><p>topic exchange与direct exchange类似，只是它允许binding_key使用特殊字符（注意，特殊字符代表的是单词，不是字母）：</p>
<ul>
<li><code>*</code>：代表一个单词</li>
<li><code>#</code>：代表零个或多个单词</li>
</ul>
<p>比如下面这个例子。routing_key定义为<code>&quot;&lt;celerity&gt;.&lt;colour&gt;.&lt;species&gt;&quot;</code>。举几个routing_key匹配的例子：</p>
<ul>
<li>quick.orange.rabbit：一，二</li>
<li>lazy.orange.elephant：一，二</li>
<li>quick.orange.fox：一</li>
<li>lazy.brown.fox：三</li>
<li>lazy.pink.rabbit：二，三（但只发一次，因为二和三是同一个队列）</li>
<li>quick.brown.fox：无，舍弃</li>
<li>orange：无，舍弃</li>
<li>quick.orange.male.rabbit：无，舍弃</li>
<li>lazy.orange.male.rabbit：三</li>
</ul>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-logsystem/python-five.png" alt="python-five"></p>
<p>当binding_key不使用这些特殊字符时，topic exchange其实就是direct exchange；当binding_key使用<code>#</code>时，topic exchange其实就是fanout exchange，也就是所有消息都接收。</p>
<p>一些极端的例子：<br>binding_key：<code>*</code>，routing_key：空串。不匹配。<br>binding_key：<code>#.*</code>，routing_key：<code>..</code>。匹配。<br>binding_key：<code>#.*</code>，routing_key：apple。匹配。</p>
<p>完整代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: emit_log_topic.py</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">        host=<span class="string">'localhost'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line">channel.exchange_declare(exchange=<span class="string">'topic_logs'</span>,</div><div class="line">                         type=<span class="string">'topic'</span>)</div><div class="line"></div><div class="line">routing_key = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span> <span class="keyword">else</span> <span class="string">'anonymous.info'</span></div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">2</span>:]) <span class="keyword">or</span> <span class="string">'Hello World!'</span></div><div class="line">channel.basic_publish(exchange=<span class="string">'topic_logs'</span>,</div><div class="line">                      routing_key=routing_key,</div><div class="line">                      body=message)</div><div class="line">print(<span class="string">" [x] Sent %r:%r"</span> % (routing_key, message))</div><div class="line">connection.close()</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: receive_logs_topic.py</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">        host=<span class="string">'localhost'</span>))</div><div class="line">channel = connection.channel()</div><div class="line"></div><div class="line">channel.exchange_declare(exchange=<span class="string">'topic_logs'</span>,</div><div class="line">                         type=<span class="string">'topic'</span>)</div><div class="line"></div><div class="line">result = channel.queue_declare(exclusive=<span class="keyword">True</span>)</div><div class="line">queue_name = result.method.queue</div><div class="line"></div><div class="line">binding_keys = sys.argv[<span class="number">1</span>:]</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> binding_keys:</div><div class="line">    sys.stderr.write(<span class="string">"Usage: %s [binding_key]...\n"</span> % sys.argv[<span class="number">0</span>])</div><div class="line">    sys.exit(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> binding_key <span class="keyword">in</span> binding_keys:</div><div class="line">    channel.queue_bind(exchange=<span class="string">'topic_logs'</span>,</div><div class="line">                       queue=queue_name,</div><div class="line">                       routing_key=binding_key)</div><div class="line"></div><div class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] %r:%r"</span> % (method.routing_key, body))</div><div class="line"></div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=queue_name,</div><div class="line">                      no_ack=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上一篇中:</p>
<blockquote>
<p>再回顾一下上面的代码。首先明确，这种情况使用的是默认exchange。对于producer，它将消息交给exchange，然后exchange通过routing key来判断要将消息交到哪个queue。实际上相当于将消息直接发送到queue中。而consumer直接指定queue的名字，也就是它直接绑定到这个queue。这个过程中exchange其实没什么存在感。</p>
</blockquote>
<p>而这一篇，实际上producer只认exchange。它只负责将消息交给exchange。consumer自己搭建queue，将queue绑定到它感兴趣的exchange上。exchange决定它以什么样的形式提供服务，是fanous还是direct。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.rabbitmq.com/tutorials/tutorial-three-python.html" target="_blank" rel="external">RabbitMQ tutorial</a></li>
</ol>
<blockquote>
<p>本文内容学习自互联网，采用<a href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 2.5 中国大陆</a>协议进行许可。如需转载，请保留文章所引用的那些原作者的信息。感谢原作者们的精彩分享。如有遗漏的引用，烦请告诉我，我将修改引用或删除文章。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ice Bear都能懂的RabbitMQ (一)]]></title>
      <url>http://skydream.me/post/2016/rabbitmq-beginner-guider-for-ice-bears-helloworld/</url>
      <content type="html"><![CDATA[<p>在Openstack中，各个组件内部使用消息队列进行通信，其中，RabbitMQ是常用的一种开源消息代理软件。这里作一个简要介绍。</p>
<a id="more"></a>
<h2 id="RabbitMQ介绍"><a href="#RabbitMQ介绍" class="headerlink" title="RabbitMQ介绍"></a>RabbitMQ介绍</h2><p>RabbitMQ实现了高级消息队列协议（AMQP）。</p>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p>AMQP是一个定义了应用之间消息传送协议的开放标准. AMQP旨在解决在两个应用之间传送消息存在的以下问题:</p>
<ul>
<li>网络是不可靠的 -&gt; 消息需要保存后再转发并有出错处理机制</li>
<li>与本地调用相比，网络速度慢 -&gt; 得支持异步调用</li>
<li>应用之间是不同的(比如实现语言不同, 操作系统不同)，且应用会经常变化 -&gt; 得与应用无关</li>
</ul>
<p>AMQP 使用异步的、应用对应用的、二进制数据通信来解决这些问题。</p>
<h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><p>RabbitMQ 是 AMQP 的一种实现, 其基本组件包括：</p>
<ul>
<li>Producer：Message的生产者, 负责产生消息并把消息发到Exchange。</li>
<li>Message：RabbitMQ 转发的二进制对象，包括Headers、Properties和 Data。其中Data不是必要的。</li>
<li>Exchange：负责接收Producer的Message, 并把它转发到合适的Queue.</li>
<li>Binding：标识Queue和Exchange之间的关系。Exchange根据Message的Properties和Binding的Properties来确定将消息转发到哪些Queue。一个重要的Properties是binding_key。</li>
<li>Queue：缓存Exchange发来的消息，并将消息主动发给Consumer或者由Consumer主动来获取消息。</li>
<li>Consumer：使用Queue从Exchange中获取Message。</li>
</ul>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-helloworld/rabbitmq-basic-structure.jpg" alt="rabbitmq-basic-structure" title="rabbitmq-basic-structure"></p>
<p>RabbitMQ有多种版本的客户端，本文使用Pika，安装如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install pika</div></pre></td></tr></table></figure></p>
<h2 id="RabbitMQ扩展插件"><a href="#RabbitMQ扩展插件" class="headerlink" title="RabbitMQ扩展插件"></a>RabbitMQ扩展插件</h2><h3 id="Management-Plugin"><a href="#Management-Plugin" class="headerlink" title="Management Plugin"></a>Management Plugin</h3><p>提供GUI来管理RabbitMQ。官方地址：<a href="https://www.rabbitmq.com/management.html" target="_blank" rel="external">https://www.rabbitmq.com/management.html</a></p>
<p>RabbitMQ用户密码可以在<code>/etc/rabbitmq/abbitmq.config</code>查看：</p>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-helloworld/rabbitmq-user-passwd.png" alt="rabbitmq-user-passwd"></p>
<p>打开图形界面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># rabbitmq-plugins enable rabbitmq_management</div></pre></td></tr></table></figure></p>
<p>然后通过端口15672就可以访问web管理界面。</p>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-helloworld/rabbitmq_management_ui.png" alt="rabbitmq_management_ui"></p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><p>首先，我们尝试从Publisher发送一条消息“Hello World”到Consumer。</p>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-helloworld/hello-world-example-routing.png" alt="hello-world-example-routing"></p>
<h3 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h3><p><strong>发送消息</strong>主要包括以下几个操作：</p>
<ol>
<li>与RabbitMQ建立连接。</li>
<li>声明要使用的queue。</li>
<li>RabbitMQ中，消息不会直接发到queue，而是发到exchange，由exchange转发到相应的queue。下面的例子中使用了默认的exchange，它会进行定向转发，也就是将message发到routing_key所指定的queue中。</li>
<li>最后，为了保证网络缓存flushed（也就是消息被发出去了），手动关闭连接。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: send.py</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'localhost'</span>))</div><div class="line">channel = connection.channel()</div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                      routing_key=<span class="string">'hello'</span>,</div><div class="line">                      body=<span class="string">'Hello World!'</span>)</div><div class="line">print(<span class="string">" [x] Sent 'Hello World!'"</span>)</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<p>执行完以上指令，通过命令行你可以看到queue已经被建立且包含了我们发出的信息：</p>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-helloworld/list_queue_hello.png" alt="list_queue_hello"></p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p><strong>接收消息</strong>主要包括以下几个操作：</p>
<ol>
<li>与RabbitMQ建立连接。</li>
<li>声明监听的queue。</li>
<li>建立consumer。comsumer需要一个回调函数来负责处理接收到的消息。</li>
<li>start_consuming()，其本质是一个while循环，不断取出队列中的消息。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: receive.py</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'localhost'</span>))</div><div class="line">channel = connection.channel()</div><div class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % body)</div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=<span class="string">'hello'</span>,</div><div class="line">                      no_ack=<span class="keyword">True</span>)</div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-helloworld/receive_hello_world.png" alt="receive_hello_world"></p>
<h2 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h2><p>在上一个例子中，consumer只是简单地打印信息，在这个例子中，我们将consumer改为一个worker，它将根据消息完成一些任务。其本质和print(“hello world”)并没有什么区别，但是为了保证任务能正确完成，需要一些额外的操作，使workder更健壮。</p>
<h3 id="consumer挂了怎么办"><a href="#consumer挂了怎么办" class="headerlink" title="consumer挂了怎么办"></a>consumer挂了怎么办</h3><p>改写以上代码。</p>
<p>publisher发送的消息可以从命令参数中读取。参数包括若干个点，点的数量决定了consumer需要花多少秒来完成任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># send.py</span></div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"Hello World!"</span></div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                      routing_key=<span class="string">'hello'</span>,</div><div class="line">                      body=message)</div><div class="line">print(<span class="string">" [x] Sent %r"</span> % message)</div></pre></td></tr></table></figure></p>
<p>consumer处理消息的回调函数，将根据message进行sleep()：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># receive.py</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % body)</div><div class="line">    time.sleep(body.count(<span class="string">b'.'</span>))</div><div class="line">    print(<span class="string">" [x] Done"</span>)</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=<span class="string">'hello'</span>)</div></pre></td></tr></table></figure></p>
<p>当consumer处理完任务，会回复ack。如果没有ack，这个消息将在queue中处于unacknowledged状态。如果这个consumer处理过程中挂了，这个message将被分发给其它consumer。这个机制<strong>保证了所有的消息都可以被处理</strong>。（一种很坏的情况是，consumer处理了message但没有返回ack，但这个consumer又一直不挂，那么这些被它处理的message就会一直以unack的状态保存在queue中。）</p>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-helloworld/list_queue_unack.png" alt="list_queue_unack"></p>
<h3 id="rabbitmq挂了怎么办"><a href="#rabbitmq挂了怎么办" class="headerlink" title="rabbitmq挂了怎么办"></a>rabbitmq挂了怎么办</h3><p>为了保证rabbitmq挂了都不会使message消失，我们必须保证：</p>
<ul>
<li>queue持久化</li>
<li>message持久化</li>
</ul>
<p>由于rabbitmq不允许两个队列重名，下面的代码改用task_queue作为队列名。修改代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: send.py</span></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                      routing_key=<span class="string">"task_queue"</span>,</div><div class="line">                      body=message,</div><div class="line">                      properties=pika.BasicProperties(</div><div class="line">                          delivery_mode=<span class="number">2</span>, )</div><div class="line">                      )</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: receive.py</span></div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<h3 id="任务平均分配"><a href="#任务平均分配" class="headerlink" title="任务平均分配"></a>任务平均分配</h3><p>目前的情况是，任务将被平均分配给每一个consumer。比如，如果有两个consumer，那么任务将你一个我一个来分配，而不会根据任务的复杂度来分配。一种极端情况是，奇数任务复杂度很高，偶数任务复杂度很低，那么就会导致一个consumer一直很忙，而另一个一直很闲。为此，进一步修改代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: receive.py</span></div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>这个参数限制了consumer手上的message数量。如果consumer手上已经有一个unack的message，那么后续的message就不会发给它了。</p>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-helloworld/prefetch-count.png" alt="prefetch-count"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: send.py</span></div><div class="line"><span class="comment"># !/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'localhost'</span>))</div><div class="line">channel = connection.channel()</div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div><div class="line">message = <span class="string">' '</span>.join(sys.argv[<span class="number">1</span>:]) <span class="keyword">or</span> <span class="string">"Hello World!"</span></div><div class="line">channel.basic_publish(exchange=<span class="string">''</span>,</div><div class="line">                      routing_key=<span class="string">"task_queue"</span>,</div><div class="line">                      body=message,</div><div class="line">                      properties=pika.BasicProperties(</div><div class="line">                          delivery_mode=<span class="number">2</span>, )</div><div class="line">                      )</div><div class="line">print(<span class="string">" [x] Sent %r"</span> % message)</div><div class="line">connection.close()</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># filename: receive.py</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> pika</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class="line">    host=<span class="string">'localhost'</span>))</div><div class="line">channel = connection.channel()</div><div class="line">channel.queue_declare(queue=<span class="string">'task_queue'</span>, durable=<span class="keyword">True</span>)</div><div class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></div><div class="line">    print(<span class="string">" [x] Received %r"</span> % body)</div><div class="line">    time.sleep(body.count(<span class="string">b'.'</span>))</div><div class="line">    print(<span class="string">" [x] Done"</span>)</div><div class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</div><div class="line">channel.basic_consume(callback,</div><div class="line">                      queue=<span class="string">'task_queue'</span>)</div><div class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</div><div class="line">channel.start_consuming()</div></pre></td></tr></table></figure>
<p>再回顾一下上面的代码。首先明确，这种情况使用的是默认exchange。对于producer，它将消息交给exchange，然后exchange通过routing key来判断要将消息交到哪个queue。实际上相当于将消息直接发送到queue中。而consumer直接指定queue的名字，也就是它直接绑定到这个queue。这个过程中exchange其实没什么存在感。</p>
<p>最后，ice bear镇楼！</p>
<p><img src="/images/posts/rabbitmq-beginner-guider-for-ice-bears-helloworld/We-Bare-Bears-300.png" alt="We-Bare-Bears-300"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://www.rabbitmq.com/tutorials/tutorial-one-python.html" target="_blank" rel="external">RabbitMQ tutorial</a></li>
<li><a href="http://www.cnblogs.com/sammyliu/p/4293011.html" target="_blank" rel="external">探索 OpenStack 之（14）：OpenStack 中 RabbitMQ 的使用 by 刘世民</a></li>
<li><a href="http://www.diggerplus.org/archives/3136" target="_blank" rel="external">RabbitMQ Performance Test</a></li>
</ol>
<blockquote>
<p>本文内容学习自互联网，采用<a href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" target="_blank" rel="external">署名-非商业性使用-相同方式共享 2.5 中国大陆</a>协议进行许可。如需转载，请保留文章所引用的那些原作者的信息。感谢原作者们的精彩分享。如有遗漏的引用，烦请告诉我，我将修改引用或删除文章。</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
